#include <BLEDevice.h>
#include <BLEUtils.h>
#include <BLEScan.h>
#include <BLEAdvertisedDevice.h>
#include <HardwareSerial.h>

#define TXD2 17
#define RXD2 16
HardwareSerial nextion(2);

// BLE UUIDs (must match server)
#define SERVICE_UUID        "12345678-1234-5678-1234-56789abcdef0"
#define STATUS_CHAR_UUID    "12345678-1234-5678-1234-56789abcdef1"
#define COMMAND_CHAR_UUID   "12345678-1234-5678-1234-56789abcdef2"

// BLE variables
static boolean doConnect = false;
static BLEAdvertisedDevice* myDevice = nullptr;
BLEClient* pClient = nullptr;
BLERemoteCharacteristic* pCommandCharacteristic = nullptr;
bool connected = false;

// BLE scan callback
class MyAdvertisedDeviceCallbacks: public BLEAdvertisedDeviceCallbacks {
  void onResult(BLEAdvertisedDevice advertisedDevice) {
    if (advertisedDevice.haveServiceUUID() && advertisedDevice.getServiceUUID().toString() == SERVICE_UUID) {
      myDevice = new BLEAdvertisedDevice(advertisedDevice);
      doConnect = true;
      BLEDevice::getScan()->stop();
    }
  }
};

// Connect to BLE server and get characteristic
bool connectToServer() {
  pClient = BLEDevice::createClient();
  if (!pClient->connect(myDevice)) return false;
  BLERemoteService* pRemoteService = pClient->getService(SERVICE_UUID);
  if (!pRemoteService) return false;
  pCommandCharacteristic = pRemoteService->getCharacteristic(COMMAND_CHAR_UUID);
  if (!pCommandCharacteristic) return false;
  connected = true;
  return true;
}

// Map Nextion ASCII text to BLE commands
String mapNextionToBLE(const String& cmd) {
  if (cmd == "MF") return "motor right";
  if (cmd == "MR") return "motor left";
  if (cmd == "144ON") return "relay 1";
  if (cmd == "144OFF") return "relay 1";
  if (cmd == "MS") return "motor stop";
  if (cmd == "440OFF") return "relay 2";
  if (cmd == "440ON") return "relay 2";
  if (cmd == "1296OFF") return "relay 3";
  if (cmd == "1296ON") return "relay 3";
  if (cmd == "2304OFF") return "relay 4";
  if (cmd == "2304ON") return "relay 4";
  if (cmd == "5760OFF") return "relay 5";
  if (cmd == "5760ON") return "relay 5";
  if (cmd == "CP") return "control power";
  // Add more as needed
  return "";
}

// Send mapped command to BLE server
void sendBLECommand(const String& mappedCmd) {
  if (connected && pCommandCharacteristic) {
    pCommandCharacteristic->writeValue(mappedCmd.c_str(), mappedCmd.length());
    Serial.print("Sent BLE: "); Serial.println(mappedCmd);
  } else {
    Serial.println("Not connected! Could not send BLE command.");
  }
}

void setup() {
  Serial.begin(115200);
  nextion.begin(115200, SERIAL_8N1, RXD2, TXD2);
  BLEDevice::init("");
  BLEScan* pBLEScan = BLEDevice::getScan();
  pBLEScan->setAdvertisedDeviceCallbacks(new MyAdvertisedDeviceCallbacks());
  pBLEScan->setActiveScan(true);
  pBLEScan->start(30, false);
}

void loop() {
  if (doConnect && myDevice != nullptr) {
    if (connectToServer()) {
      Serial.println("BLE setup complete.");
    }
    doConnect = false;
  }

  // Read from Nextion (ASCII text)
  if (nextion.available()) {
    String data = "";
    delay(30); // Let buffer fill
    while (nextion.available()) data += (char)nextion.read();
    data.trim();
    Serial.print("From Nextion: ");
    Serial.println(data);

    String bleCmd = mapNextionToBLE(data);
    if (bleCmd.length() > 0) {
      sendBLECommand(bleCmd);
    } else {
      Serial.println("Unknown Nextion command, not sent.");
    }
  }

  if (connected && !pClient->isConnected()) {
    connected = false;
    BLEDevice::getScan()->start(0);
  }
  delay(20);
}
